@page "/ico"
@using BlazorComponent
@using Dotnet9.Tools.Web.Shared.Public
@using Dotnet9.Tools.Web.Utils
@using Dotnet9.Tools.Images
@layout DocLayout

<PageTitle>D9工具箱 - Icon转换</PageTitle>

<h1 class="entry-title">Icon转换</h1>

<MRow>
    <MCol>
        <div>请选择需要转换的图片，比如：png、jpg、jpeg、tmp等，默认转换的图片尺寸包含：16x16+32x32+48x48+256x256，转换完成不会保存源文件和生成的Icon图标，请放心使用。</div>
    </MCol>
</MRow>

<MRow>
    <MCol Lg="8" Md="8">
        <MFileInput TValue="IBrowserFile"
                    Placeholder="请选择源图片"
                    Rules="_rules"
                    ShowSize
                    OnChange="@LoadFile"
                    Accept="image/png, image/jpeg, image/jpg, image/bmp"
                    Label="源图片">
        </MFileInput>
    </MCol>

    <MCol Lg="4" Md="4">
        @if (_sourceBrowserFile != null)
        {
            <MButton class="ma-2 white--text"
                     Loading="_loading"
                     Disabled="_loading"
                     Depressed Color="primary"
                     OnClick="@ConvertAndDownloadIcon">
                <LoaderContent>
                    <span>转换Ico中...</span>
                </LoaderContent>
                <ChildContent>
                    <span>立即转换并下载Icon</span>
                </ChildContent>
            </MButton>
        }
    </MCol>
</MRow>

<ToolMarkdown
    LocalPostFilePath="@SitePathHelper.ToolsIconMarkdown"
    RemotePostUrl="@SitePathHelper.ToolsIconMainPostUrl"
    SourceCodeUrl="@SitePathHelper.ToolsIconSourceUrl"/>

@code
{
    private readonly List<Func<IBrowserFile, StringBoolean>> _rules = new();

    private bool _loading;
    private IBrowserFile? _sourceBrowserFile;

    [Inject]
    private IJSRuntime _js { get; set; } = null!;

    protected override async Task OnInitializedAsync()
    {
        _rules.Add(value => value == null || value.Size < 2 * 1024 * 1024 ? true : "请选择小于2MB的图片");
        await base.OnInitializedAsync();
    }

    private async Task LoadFile(IBrowserFile? e)
    {
        _sourceBrowserFile = e;
        await Task.CompletedTask;
    }

    private async Task ConvertAndDownloadIcon()
    {
        if (_sourceBrowserFile == null) return;

        _loading = true;
        var tempSourcePath = Path.GetTempFileName();
        var tempDestPath = Path.GetTempFileName();

        try
        {
            var fileName = $"{Path.GetFileNameWithoutExtension(_sourceBrowserFile.Name)}.ico";
            await UploadFile(tempSourcePath);

            ImagingHelper.ConvertToIcon(tempSourcePath, tempDestPath);

            await DownloadFile(tempDestPath, fileName);
        }
        finally
        {
            await DeleteFile(tempSourcePath);
            await DeleteFile(tempDestPath);

            _loading = false;
        }
    }

    private async Task UploadFile(string saveFilePath)
    {
        await using var sourceFileStream = new FileStream(saveFilePath, FileMode.Create);
        await _sourceBrowserFile!.OpenReadStream().CopyToAsync(sourceFileStream);
    }

    private async Task DownloadFile(string fromFilePath, string saveFileName)
    {
        await using var destFileStream = new FileStream(fromFilePath, FileMode.Open);
        using var streamRef = new DotNetStreamReference(destFileStream);
        await _js.InvokeVoidAsync("downloadFileFromStream", saveFileName, streamRef);
    }

    private static async Task DeleteFile(string filePath)
    {
        try
        {
            if (File.Exists(filePath)) File.Delete(filePath);
        }
        catch
        {
    // ignored
        }
        await Task.CompletedTask;
    }
}