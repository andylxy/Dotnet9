@page "/ico"
@using BlazorComponent
@using Dotnet9.Tools.Web.Shared.Public
@using Dotnet9.Tools.Web.Utils
@using Dotnet9.Tools.Images
@layout DocLayout

<PageTitle>@T("Dotnet9ToolsTitle") - @T("IcoToolTitle")</PageTitle>

<h1 class="entry-title">@T("IcoToolTitle")</h1>

<MRow>
    <MCol>
        <div>@T("IcoToolUseMemo")</div>
    </MCol>
</MRow>

<MRow>
    <MCol Lg="8" Md="8">
        <MFileInput TValue="IBrowserFile"
                    Placeholder="@T("IcoToolMFileInputPlaceholder")"
                    Rules="_rules"
                    ShowSize
                    OnChange="@LoadFile"
                    Accept="image/png, image/jpeg, image/jpg, image/bmp"
                    Label="@T("IcoToolMFileInputLabel")">
        </MFileInput>
    </MCol>

    <MCol Lg="4" Md="4">
        @if (_sourceBrowserFile != null)
        {
            <MButton class="ma-2 white--text"
                     Loading="_loading"
                     Disabled="_loading"
                     Depressed Color="primary"
                     OnClick="@ConvertAndDownloadIcon">
                <LoaderContent>
                    <span>@T("IcoToolMButtonLoaderContent")</span>
                </LoaderContent>
                <ChildContent>
                    <span>@T("IcoToolMButtonChildContent")</span>
                </ChildContent>
            </MButton>
        }
    </MCol>
</MRow>

<ToolMarkdown
    LocalPostFilePath="@SitePathHelper.ToolsIconMarkdown"
    RemotePostUrl="@SitePathHelper.ToolsIconMainPostUrl"
    SourceCodeUrl="@SitePathHelper.ToolsIconSourceUrl"/>

@code
{
    private readonly List<Func<IBrowserFile, StringBoolean>> _rules = new();

    private bool _loading;
    private IBrowserFile? _sourceBrowserFile;

    [Inject]
    private IJSRuntime _js { get; set; } = null!;

    [CascadingParameter]
    public PublicLayout? MainLayout { get; set; }

    protected override async Task OnInitializedAsync()
    {
        _rules.Add(value => value == null || value.Size < 2 * 1024 * 1024 ? true : T("IcoToolFileSizeLimitMessage"));
        await base.OnInitializedAsync();
    }

    private async Task LoadFile(IBrowserFile? e)
    {
        _sourceBrowserFile = e;
        await Task.CompletedTask;
    }

    private async Task ConvertAndDownloadIcon()
    {
        if (_sourceBrowserFile == null) return;

        _loading = true;
        var tempSourcePath = Path.GetTempFileName();
        var tempDestPath = Path.GetTempFileName();

        try
        {
            var fileName = $"{Path.GetFileNameWithoutExtension(_sourceBrowserFile.Name)}.ico";
            await UploadFile(tempSourcePath);

            ImagingHelper.ConvertToIcon(tempSourcePath, tempDestPath);

            await DownloadFile(tempDestPath, fileName);
        }
        finally
        {
            await DeleteFile(tempSourcePath);
            await DeleteFile(tempDestPath);

            _loading = false;
        }
    }

    private async Task UploadFile(string saveFilePath)
    {
        await using var sourceFileStream = new FileStream(saveFilePath, FileMode.Create);
        await _sourceBrowserFile!.OpenReadStream().CopyToAsync(sourceFileStream);
    }

    private async Task DownloadFile(string fromFilePath, string saveFileName)
    {
        await using var destFileStream = new FileStream(fromFilePath, FileMode.Open);
        using var streamRef = new DotNetStreamReference(destFileStream);
        await _js.InvokeVoidAsync("downloadFileFromStream", saveFileName, streamRef);
    }

    private static async Task DeleteFile(string filePath)
    {
        try
        {
            if (File.Exists(filePath)) File.Delete(filePath);
        }
        catch
        {
    // ignored
        }
        await Task.CompletedTask;
    }

    public string T(string key)
    {
        return MainLayout?.T(key) ?? string.Empty;
    }
}